// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgtype"
)

const checkSlugExists = `-- name: CheckSlugExists :one
SELECT EXISTS(SELECT 1 FROM news WHERE slug = $1)
`

func (q *Queries) CheckSlugExists(ctx context.Context, slug string) (bool, error) {
	row := q.db.QueryRow(ctx, checkSlugExists, slug)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const countOwners = `-- name: CountOwners :one
SELECT count(*) FROM owners
`

func (q *Queries) CountOwners(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countOwners)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createNews = `-- name: CreateNews :one
INSERT INTO news (
    title, content, thumbnail, slug, 
    published_at, status, meta_title, meta_description
)
VALUES (
    $1, $2, $3, $4, 
    NOW(), 'published', $1, SUBSTRING($2 FROM 1 FOR 160)
)
RETURNING id, author_id, category_id, title, slug, content, thumbnail, meta_title, meta_description, keywords, status, views_count, published_at, created_at, updated_at
`

type CreateNewsParams struct {
	Title     string
	Content   string
	Thumbnail string
	Slug      string
}

func (q *Queries) CreateNews(ctx context.Context, arg CreateNewsParams) (News, error) {
	row := q.db.QueryRow(ctx, createNews,
		arg.Title,
		arg.Content,
		arg.Thumbnail,
		arg.Slug,
	)
	var i News
	err := row.Scan(
		&i.ID,
		&i.AuthorID,
		&i.CategoryID,
		&i.Title,
		&i.Slug,
		&i.Content,
		&i.Thumbnail,
		&i.MetaTitle,
		&i.MetaDescription,
		&i.Keywords,
		&i.Status,
		&i.ViewsCount,
		&i.PublishedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createOwner = `-- name: CreateOwner :one
INSERT INTO owners (name, email, password_hash, role)
VALUES ($1, $2, $3, 'admin')
RETURNING id, name, email, password_hash, role, last_login, created_at, updated_at
`

type CreateOwnerParams struct {
	Name         string
	Email        string
	PasswordHash string
}

func (q *Queries) CreateOwner(ctx context.Context, arg CreateOwnerParams) (Owner, error) {
	row := q.db.QueryRow(ctx, createOwner, arg.Name, arg.Email, arg.PasswordHash)
	var i Owner
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.PasswordHash,
		&i.Role,
		&i.LastLogin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteNews = `-- name: DeleteNews :execresult
DELETE FROM news
WHERE id = $1
`

func (q *Queries) DeleteNews(ctx context.Context, id uuid.UUID) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, deleteNews, id)
}

const getNews = `-- name: GetNews :one
SELECT id, author_id, category_id, title, slug, content, thumbnail, meta_title, meta_description, keywords, status, views_count, published_at, created_at, updated_at FROM news
WHERE slug = $1 LIMIT 1
`

func (q *Queries) GetNews(ctx context.Context, slug string) (News, error) {
	row := q.db.QueryRow(ctx, getNews, slug)
	var i News
	err := row.Scan(
		&i.ID,
		&i.AuthorID,
		&i.CategoryID,
		&i.Title,
		&i.Slug,
		&i.Content,
		&i.Thumbnail,
		&i.MetaTitle,
		&i.MetaDescription,
		&i.Keywords,
		&i.Status,
		&i.ViewsCount,
		&i.PublishedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getNewsAPI = `-- name: GetNewsAPI :one
SELECT id, title, content, thumbnail, slug, status, meta_title, meta_description, views_count, published_at, created_at, updated_at
FROM news
WHERE slug = $1 LIMIT 1
`

type GetNewsAPIRow struct {
	ID              uuid.UUID
	Title           string
	Content         string
	Thumbnail       string
	Slug            string
	Status          string
	MetaTitle       pgtype.Text
	MetaDescription pgtype.Text
	ViewsCount      pgtype.Int8
	PublishedAt     pgtype.Timestamptz
	CreatedAt       pgtype.Timestamptz
	UpdatedAt       pgtype.Timestamptz
}

func (q *Queries) GetNewsAPI(ctx context.Context, slug string) (GetNewsAPIRow, error) {
	row := q.db.QueryRow(ctx, getNewsAPI, slug)
	var i GetNewsAPIRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Content,
		&i.Thumbnail,
		&i.Slug,
		&i.Status,
		&i.MetaTitle,
		&i.MetaDescription,
		&i.ViewsCount,
		&i.PublishedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getOwnerByEmail = `-- name: GetOwnerByEmail :one
SELECT id, name, email, password_hash, role, last_login, created_at, updated_at FROM owners
WHERE email = $1 LIMIT 1
`

func (q *Queries) GetOwnerByEmail(ctx context.Context, email string) (Owner, error) {
	row := q.db.QueryRow(ctx, getOwnerByEmail, email)
	var i Owner
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.PasswordHash,
		&i.Role,
		&i.LastLogin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const incrementNewsViews = `-- name: IncrementNewsViews :exec
UPDATE news 
SET views_count = views_count + 1 
WHERE slug = $1
`

func (q *Queries) IncrementNewsViews(ctx context.Context, slug string) error {
	_, err := q.db.Exec(ctx, incrementNewsViews, slug)
	return err
}

const listNews = `-- name: ListNews :many
SELECT id, title, thumbnail, slug, status, views_count, published_at, created_at, updated_at
FROM news
WHERE status = 'published' AND published_at <= NOW()
ORDER BY published_at DESC
LIMIT $1 OFFSET $2
`

type ListNewsParams struct {
	Limit  int32
	Offset int32
}

type ListNewsRow struct {
	ID          uuid.UUID
	Title       string
	Thumbnail   string
	Slug        string
	Status      string
	ViewsCount  pgtype.Int8
	PublishedAt pgtype.Timestamptz
	CreatedAt   pgtype.Timestamptz
	UpdatedAt   pgtype.Timestamptz
}

func (q *Queries) ListNews(ctx context.Context, arg ListNewsParams) ([]ListNewsRow, error) {
	rows, err := q.db.Query(ctx, listNews, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListNewsRow
	for rows.Next() {
		var i ListNewsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Thumbnail,
			&i.Slug,
			&i.Status,
			&i.ViewsCount,
			&i.PublishedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateNews = `-- name: UpdateNews :execresult
UPDATE news
SET 
    title = $2, 
    content = $3, 
    thumbnail = $4, 
    updated_at = NOW()
WHERE id = $1
`

type UpdateNewsParams struct {
	ID        uuid.UUID
	Title     string
	Content   string
	Thumbnail string
}

func (q *Queries) UpdateNews(ctx context.Context, arg UpdateNewsParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, updateNews,
		arg.ID,
		arg.Title,
		arg.Content,
		arg.Thumbnail,
	)
}
